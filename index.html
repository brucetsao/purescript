<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Purescript : A small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Purescript</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/paf31/purescript">View on GitHub</a>

          <h1 id="project_title">Purescript</h1>
          <h2 id="project_tagline">A small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/paf31/purescript/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/paf31/purescript/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="purescript" class="anchor" href="#purescript"><span class="octicon octicon-link"></span></a>purescript</h1>

<p><a href="http://travis-ci.org/paf31/purescript"><img src="https://secure.travis-ci.org/paf31/purescript.png?branch=master" alt="Build Status"></a></p>

<p>A small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks</p>

<p>Bitcoin donations are gratefully accepted at 14ZhCym28WDuFhocP44tU1dBpCzjX1DvhF.</p>

<h2>
<a name="current-features" class="anchor" href="#current-features"><span class="octicon octicon-link"></span></a>Current Features</h2>

<ul>
<li>Full Type Inference</li>
<li>Higher Kinded Polymorphism</li>
<li>Support for basic Javascript types</li>
<li>Extensible records</li>
<li>Type-safe blocks with for/while/assignment etc.</li>
<li>Functions with multiple arguments</li>
<li>Pattern matching</li>
<li>Simple FFI</li>
</ul><h2>
<a name="experimental-features" class="anchor" href="#experimental-features"><span class="octicon octicon-link"></span></a>Experimental Features</h2>

<ul>
<li>Modules</li>
<li>Rank N Types</li>
</ul><h2>
<a name="try-it" class="anchor" href="#try-it"><span class="octicon octicon-link"></span></a>Try It!</h2>

<p>Try PureScript in the browser <a href="http://tryps.functorial.com/">here</a>.</p>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>See the <code>LICENSE</code> file</p>

<h2>
<a name="contributing" class="anchor" href="#contributing"><span class="octicon octicon-link"></span></a>Contributing</h2>

<p>Contributions are always encouraged! Please see <code>CONTRIBUTING.md</code> for guidelines.</p>

<h2>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Install the Haskell Plaform, then <code>cabal install</code></p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>The <code>psc</code> executable takes a list of PureScript source files as arguments and by default writes out its errors or output to the console.</p>

<p>The following options are supported:</p>

<pre><code>-s --stdin
    Read input from standard input instead of from files

-o --output 
    Write the generated Javascript to the specified file

-e --foreign imports
    Write a list of foreign imports declarations to the specified file in addition to generating Javascript output
</code></pre>

<h2>
<a name="motivation" class="anchor" href="#motivation"><span class="octicon octicon-link"></span></a>Motivation</h2>

<p>I was looking for a simple functional language which would compile to JavaScript and have the following characteristics:</p>

<ul>
<li>Generate simple readable Javascript</li>
<li>Provide the ability to compile to tight loops if necessary</li>
<li>Reasonable type system</li>
<li>Ideally, written in a programming language I would enjoy working in</li>
<li>Provides a simple interface to existing Javascript code</li>
</ul><p>I didn't find exactly what I was looking for, so I wrote PureScript. It doesn't have everything right now, but it should serve as a simple core on which to develop new ideas.</p>

<p>PureScript is <em>not</em> designed to be a general-purpose programming language. The primary use case is as a generator for purely-functional core libraries, with the main application code written in another language.</p>

<p>PureScript can also be seen as a trade-off between a theoretically ideal language and one which generates reasonably high performance code.</p>

<h2>
<a name="hello-purescript" class="anchor" href="#hello-purescript"><span class="octicon octicon-link"></span></a>Hello, PureScript!</h2>

<p>As an introductory example, here is the usual "Hello World" written in PureScript:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">console</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">log</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">{}</span> <span class="p">}</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="nf">\</span> <span class="ow">-&gt;</span> <span class="n">console</span><span class="o">.</span><span class="n">log</span> <span class="s">"Hello, World!"</span>
</pre></div>

<p>which compiles to the following Javascript:</p>

<div class="highlight highlight-javascript"><pre><span class="kd">function</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello, World!"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="another-example" class="anchor" href="#another-example"><span class="octicon octicon-link"></span></a>Another Example</h2>

<p>The following code defines a <code>Person</code> data type and a function to generate a string representation for a <code>Person</code>:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">name</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Number</span> <span class="p">}</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">numberToString</span> <span class="ow">::</span> <span class="kt">Number</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="nf">showPerson</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">showPerson</span> <span class="p">(</span><span class="kt">Person</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">++</span> <span class="s">", aged "</span> <span class="o">++</span> <span class="n">numberToString</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">age</span><span class="p">)</span>
</pre></div>

<p>Line by line, this reads as follows:</p>

<ul>
<li>
<code>Person</code> is a data type with one constructor, also called <code>Person</code>

<ul>
<li>The <code>Person</code> constructor takes an object with two properties, <code>name</code> which is a <code>String</code>, and <code>age</code> which is a <code>Number</code>
</li>
</ul>
</li>
<li>The <code>numberToString</code> function is written in Javascript, and converts a <code>Number</code> to its <code>String</code> representation</li>
<li>The <code>showPerson</code> function takes a <code>Person</code> and returns a <code>String</code>
</li>
<li>
<code>showPerson</code> works by case analysis on its argument, first matching the constructor <code>Person</code> and then using string concatenation and object accessors to return its result.</li>
</ul><p>The generated Javascript looks like this:</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="p">{</span> <span class="nx">ctor</span><span class="o">:</span> <span class="s1">'Person'</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">};</span> 
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">showPerson</span><span class="p">(</span><span class="nx">_1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">_1</span><span class="p">.</span><span class="nx">ctor</span> <span class="o">===</span> <span class="s2">"Person"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">_1</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">", aged "</span> <span class="o">+</span> <span class="nx">numberToString</span><span class="p">(</span><span class="nx">_1</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> 
    <span class="p">};</span> 
    <span class="k">throw</span> <span class="s2">"Failed pattern match"</span><span class="p">;</span> 
<span class="p">};</span> 

</pre></div>

<h2>
<a name="type-system" class="anchor" href="#type-system"><span class="octicon octicon-link"></span></a>Type System</h2>

<p>The type system defines the following types:</p>

<ul>
<li>Primitive Types

<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
</ul>
</li>
<li>Arrays 

<ul>
<li>E.g. <code>[String]</code>, <code>[[Number]]</code>
</li>
</ul>
</li>
<li>Records

<ul>
<li>E.g. <code>{ foo :: String, bar :: Number }</code>
</li>
</ul>
</li>
<li>Tagged Unions

<ul>
<li>E.g. <code>data Foo a = Foo | Bar String</code>
</li>
</ul>
</li>
<li>Functions

<ul>
<li>E.g. <code>Number -&gt; String</code>
</li>
<li>E.g. <code>(Number, Number) -&gt; Number</code>
</li>
<li>Functions can have zero or more arguments</li>
</ul>
</li>
<li>Polymorphic types

<ul>
<li>E.g. <code>forall a. a -&gt; a</code> </li>
</ul>
</li>
</ul><h2>
<a name="primitive-types" class="anchor" href="#primitive-types"><span class="octicon octicon-link"></span></a>Primitive Types</h2>

<p>The three primitive types <code>String</code>, <code>Number</code> and <code>Boolean</code> correspond to their Javascript equivalents at runtime.</p>

<p>PureScript supports the same binary and unary operations on primitive types as Javascript, with the following exceptions:</p>

<ul>
<li>String concatenation is denoted <code>++</code> to differentiate it from numeric addition, <code>+</code>
</li>
<li>PureScript's <code>==</code> and <code>!=</code> correspond to Javascript's strong equality tests <code>===</code> and <code>!==</code>
</li>
</ul><p>Examples:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">num</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span>
<span class="nf">str</span> <span class="ow">=</span> <span class="s">"Hello, "</span> <span class="o">++</span> <span class="s">"World!"</span>
<span class="nf">bool</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">true</span>
</pre></div>

<h2>
<a name="arrays" class="anchor" href="#arrays"><span class="octicon octicon-link"></span></a>Arrays</h2>

<p>PureScript arrays correspond to Javascript arrays at runtime, but all elements must have the same type.</p>

<p>Array literals look like Javascript array literals: <code>[1, 2, 3]</code></p>

<p>Array elements can be read using array index notation <code>arr !! index</code></p>

<h2>
<a name="records" class="anchor" href="#records"><span class="octicon octicon-link"></span></a>Records</h2>

<p>PureScript records correspond to Javascript objects.</p>

<p>Record literals look like Javascript object literals: <code>{ foo: "Foo" }</code></p>

<p>Properties can be read by using dot notation: <code>o.foo</code></p>

<h2>
<a name="tagged-unions" class="anchor" href="#tagged-unions"><span class="octicon octicon-link"></span></a>Tagged Unions</h2>

<p>Tagged unions consist of one or more constructors, each of which takes zero or one arguments.</p>

<p>Tagged unions can only be created using their constructors, and deconstructed through pattern matching (see later).</p>

<p>For example:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Foo</span> <span class="o">|</span> <span class="kt">Bar</span> <span class="kt">String</span>

<span class="nf">runFoo</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="s">"It's a Foo"</span>
<span class="nf">runFoo</span> <span class="p">(</span><span class="kt">Bar</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="s">"It's a Bar. The string is "</span> <span class="o">++</span> <span class="n">s</span>

<span class="nf">test</span> <span class="ow">=</span> <span class="n">runFoo</span> <span class="kt">Foo</span> <span class="o">++</span> <span class="n">runFoo</span> <span class="p">(</span><span class="kt">Bar</span> <span class="s">"Test"</span><span class="p">)</span>
</pre></div>

<p>In the example, Foo is a tagged union type which has two constructors. It's first constructor <code>Foo</code> takes no argument, and it's second <code>Bar</code> takes one, which must be a String.</p>

<p><code>runFoo</code> is an example of pattern matching on a tagged union type to discover its constructor, and the last line shows how <code>Foo</code>s are constructed.</p>

<h2>
<a name="functions" class="anchor" href="#functions"><span class="octicon octicon-link"></span></a>Functions</h2>

<p>Functions in PureScript can have zero or more arguments in general, just like in Javascript.</p>

<p>Functions are introduced by using a backslash followed by a list of argument names:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test1</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>

<p>which would correspond to the Javascript </p>

<div class="highlight highlight-javascript"><pre><span class="kd">function</span> <span class="nx">test1</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Multiple argument functions can be introduced by wrapping the arguments in parentheses, and separating them with commas:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test1</span> <span class="ow">=</span> <span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>

<p>which generates</p>

<div class="highlight highlight-javascript"><pre><span class="kd">function</span> <span class="nx">test1</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>In the case of a function with no arguments, the parentheses may be omitted, as follows:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test2</span> <span class="ow">=</span> <span class="nf">\</span> <span class="ow">-&gt;</span> <span class="mi">100</span>
</pre></div>

<p>which would correspond to the Javascript <code>function test2() { return 100; }</code></p>

<p>Multiple-argument and single-argument syntax can be mixed, as follows:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test3</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="n">d</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
</pre></div>

<p>which generates</p>

<div class="highlight highlight-javascript"><pre><span class="kd">function</span> <span class="nx">test3</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">d</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Functions are applied by providing their arguments inside parentheses:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">test2</span><span class="nb">()</span>
</pre></div>

<p>A special case is made in the case of functions with one argument. These functions can be applied without parentheses, and function application associates to the left:</p>

<div class="highlight highlight-haskell"><pre><span class="c1">-- has type Number -&gt; Number -&gt; Number -&gt; Number</span>
<span class="nf">addThree</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>

<span class="c1">-- has type Number -&gt; Number -&gt; Number</span>
<span class="nf">addThree</span> <span class="mi">1</span> 

<span class="c1">-- has type Number -&gt; Number</span>
<span class="nf">addThree</span> <span class="mi">1</span> <span class="mi">2</span> 

<span class="c1">-- has type Number</span>
<span class="nf">addThree</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> 
</pre></div>

<h2>
<a name="polymorphic-types" class="anchor" href="#polymorphic-types"><span class="octicon octicon-link"></span></a>Polymorphic Types</h2>

<p>Expressions defined at the top level may have polymorphic types.</p>

<p>Here is an example:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">identity</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>

<p><code>identity</code> is inferred to have (polymorphic) type <code>forall t0. t0 -&gt; t0</code>. This means that for any type <code>t0</code>, <code>identity</code> can be given a value of type <code>t0</code> and will give back a value of the same type.</p>

<p>A type annotation can also be provided:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">identity</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">identity</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>

<p>Functions may also be polymorphic in row types or type variables with other kinds (see "Kind System"):</p>

<div class="highlight highlight-haskell"><pre><span class="nf">addProps</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">bar</span>
</pre></div>

<p>Here, <code>addProps</code> is inferred to have type <code>forall r. { foo :: Number, bar :: Number | r } -&gt; Number</code>. That is, it can take any type which has properties <code>Foo</code> and <code>Bar</code>, and <em>any other record properties</em>.</p>

<p>So, the following compiles:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">addProps</span> <span class="p">{</span> <span class="n">foo</span><span class="kt">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bar</span><span class="kt">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">baz</span><span class="kt">:</span> <span class="mi">3</span> <span class="p">}</span>
</pre></div>

<p>but the following does not:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">addProps</span> <span class="p">{</span> <span class="n">foo</span><span class="kt">:</span> <span class="mi">1</span> <span class="p">}</span>
</pre></div>

<p>since the <code>bar</code> property is missing.</p>

<p>Again, a type annotation can be provided if necessary.</p>

<h2>
<a name="rank-n-types-experimental-feature" class="anchor" href="#rank-n-types-experimental-feature"><span class="octicon octicon-link"></span></a>Rank N Types (Experimental Feature)</h2>

<p>It is also possible for the <code>forall</code> quantifier to appear on the left of a function arrow, inside types record fields and data constructors, and in type synonyms.</p>

<p>In most cases, a type annotation is necessary when using this feature.</p>

<p>As an example, we can pass a polymorphic function as an argument to another function:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">poly</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Boolean</span>
<span class="nf">poly</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span> <span class="n">true</span>
</pre></div>

<p>Notice that the polymorphic function's type argument is instantiated to both <code>Number</code> and <code>Boolean</code>.</p>

<p>An argument to <code>poly</code> must indeed be polymorphic. For example, the following fails:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test</span> <span class="ow">=</span> <span class="n">poly</span> <span class="p">(</span><span class="nf">\</span><span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>since the skolemized type variable <code>a</code> does not unify with <code>Number</code>.</p>

<h2>
<a name="type-inference" class="anchor" href="#type-inference"><span class="octicon octicon-link"></span></a>Type Inference</h2>

<p>All types can be inferred, but annotations can optionally be provided.</p>

<h2>
<a name="kind-system" class="anchor" href="#kind-system"><span class="octicon octicon-link"></span></a>Kind System</h2>

<p>There are two primitive kinds, the kind <code>*</code> of types and the kind <code>#</code> of rows. Higher kinded types are also supported. That is, a type variable can refer to not only a type or a row, but a type constructor, or row constructor etc.</p>

<h2>
<a name="whitespace" class="anchor" href="#whitespace"><span class="octicon octicon-link"></span></a>Whitespace</h2>

<p>Syntax is whitespace sensitive. The general rule of thumb is that declarations which span multiple lines should be indented past the column on which they were first defined on their subsequent lines.</p>

<p>That is, the following is valid:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foo</span> <span class="ow">=</span> <span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> 
  <span class="n">baz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>But this is not:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foo</span> <span class="ow">=</span> <span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> 
<span class="nf">baz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<h2>
<a name="blocks" class="anchor" href="#blocks"><span class="octicon octicon-link"></span></a>Blocks</h2>

<p>Blocks are collections of statements wrapped in braces <code>{ ... }</code>. Blocks must return a value of the same type on every branch of execution.</p>

<p>The following types of statement are supported:</p>

<ul>
<li>Variable introduction</li>
<li>Variable assignment</li>
<li>For loops</li>
<li>For-each loops</li>
<li>While loops</li>
<li>If-Then-Else statements</li>
<li>Naked expressions</li>
</ul><p>Here is an example of a power function defined using a block:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">pow</span> <span class="n">n</span> <span class="n">p</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">for</span> <span class="p">(</span><span class="n">i</span> <span class="ow">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">return</span> <span class="n">m</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<p>Blocks enable local mutation of their variables, but mutation is not allowed in general. The type system prevents mutable variables from escaping their scope.</p>

<p>That is, while the example above is valid, the following does not compile:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">incr</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<p>The variable <code>n</code> is not mutable, and so the assignment in the first line of the <code>do</code> block is not allowed.</p>

<p>This function can be rewritten as follows:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">incr</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">return</span> <span class="n">m</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<h2>
<a name="for-loops" class="anchor" href="#for-loops"><span class="octicon octicon-link"></span></a>For Loops</h2>

<p>For loops look like this:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">total</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">n</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for</span> <span class="p">(</span><span class="n">i</span> <span class="ow">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<p>The bounds <code>0</code> and <code>10</code> are inclusive and exclusive respectively.</p>

<h2>
<a name="for-each-loops" class="anchor" href="#for-each-loops"><span class="octicon octicon-link"></span></a>For-Each Loops</h2>

<p>For each loops loop over the elements in an array using the <code>Object.forEach</code> method. A polyfill may be required for some browsers:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">total</span> <span class="n">arr</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">n</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="n">i</span> <span class="kr">in</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<h2>
<a name="while-loops" class="anchor" href="#while-loops"><span class="octicon octicon-link"></span></a>While Loops</h2>

<p>The syntax of a while loop is similar to a foreach loop:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">log2</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">count</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">var</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="n">count</span> <span class="ow">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">return</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<h2>
<a name="if-then-else-statements" class="anchor" href="#if-then-else-statements"><span class="octicon octicon-link"></span></a>If-Then-Else Statements</h2>

<p>Else branches are optional, and may contain further <code>if</code> statements, just as in Javascript:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">collatz</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">count</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">var</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span> <span class="kr">else</span> <span class="p">{</span>
        <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">count</span> <span class="ow">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">return</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<h2>
<a name="naked-expressions-as-statements" class="anchor" href="#naked-expressions-as-statements"><span class="octicon octicon-link"></span></a>Naked Expressions as Statements</h2>

<p>Any expression with the empty type <code>{ }</code> can be used as a statement in a block. For example, method calls which return <code>{ }</code>:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">example</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="p">{</span>
    <span class="n">console</span><span class="o">.</span><span class="n">log</span> <span class="s">"Adding two numbers"</span>
    <span class="n">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>

<h2>
<a name="if-then-else-expressions" class="anchor" href="#if-then-else-expressions"><span class="octicon octicon-link"></span></a>If-Then-Else Expressions</h2>

<p>The <code>if</code>, <code>then</code> and <code>else</code> keywords can also be used to create conditional expressions. In this case, the <code>else</code> block is always required.</p>

<p>For example,</p>

<div class="highlight highlight-haskell"><pre><span class="nf">conditional</span> <span class="ow">=</span> <span class="kr">if</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="kr">then</span> <span class="s">"ok"</span> <span class="kr">else</span> <span class="s">"oops"</span>
</pre></div>

<h2>
<a name="pattern-matching" class="anchor" href="#pattern-matching"><span class="octicon octicon-link"></span></a>Pattern Matching</h2>

<p>Pattern matching deconstructs a value to bring zero or more expressions into scope. Pattern matches are introduced with the <code>case</code> keyword.</p>

<p>Pattern matches have the following general form</p>

<div class="highlight highlight-haskell"><pre><span class="kr">case</span> <span class="n">value</span> <span class="kr">of</span>
  <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
  <span class="c1">-- ...</span>
  <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
</pre></div>

<p>Pattern matching can also be used in the declaration of functions, as we have already seen:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">fn</span> <span class="n">pattern_1</span> <span class="o">...</span> <span class="n">pattern_n</span> <span class="ow">=</span> <span class="n">result</span>
</pre></div>

<p>Any of the above types of pattern are also valid when introducing functions. In addition, patterns can also be grouped in parentheses to introduce multiple-arugument functions. For example, </p>

<div class="highlight highlight-haskell"><pre><span class="nf">example</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">w</span>
</pre></div>

<p>The following pattern types are supported:</p>

<ul>
<li>Wildcard pattern</li>
<li>Literal patterns</li>
<li>Variable pattern</li>
<li>Array patterns</li>
<li>Cons patterns</li>
<li>Record patterns</li>
<li>Named patterns</li>
<li>Guards</li>
</ul><p>Patterns need not be exhaustive. A pattern match failed exception will be thrown at runtime if no pattern matches the input.</p>

<h2>
<a name="wildcard-patterns" class="anchor" href="#wildcard-patterns"><span class="octicon octicon-link"></span></a>Wildcard Patterns</h2>

<p>The wilcard <code>_</code> matches any input and brings nothing into scope:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> 
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
</pre></div>

<h2>
<a name="literal-patterns" class="anchor" href="#literal-patterns"><span class="octicon octicon-link"></span></a>Literal Patterns</h2>

<p>Literal patterns are provided to match on primitives:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">case</span> <span class="n">booleanValue</span> <span class="kr">of</span> 
  <span class="n">true</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
  <span class="n">false</span> <span class="ow">-&gt;</span> <span class="mi">1</span>

<span class="kr">case</span> <span class="n">stringValue</span> <span class="kr">of</span> 
  <span class="s">"Foo"</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>

<span class="kr">case</span> <span class="n">numericValue</span> <span class="kr">of</span> 
  <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
</pre></div>

<h2>
<a name="variable-pattern" class="anchor" href="#variable-pattern"><span class="octicon octicon-link"></span></a>Variable Pattern</h2>

<p>A variable pattern matches any input and binds that input to its name:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">case</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="kr">of</span>
  <span class="n">result</span> <span class="ow">-&gt;</span> <span class="n">bar</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>

<h2>
<a name="array-patterns" class="anchor" href="#array-patterns"><span class="octicon octicon-link"></span></a>Array Patterns</h2>

<p>Array patterns match an input which is an array, and bring its elements into scope.</p>

<p>For example:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">arr</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">arr</span> <span class="kr">of</span>
  <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">x</span>
  <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">f</span> <span class="n">xs</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
</pre></div>

<p>Here, the first pattern only matches arrays of length one, and brings the first element of the array into scope.</p>

<p>The second pattern matches arrays with two elements, and brings the first and second elements into scope.</p>

<h2>
<a name="cons-patterns" class="anchor" href="#cons-patterns"><span class="octicon octicon-link"></span></a>Cons Patterns</h2>

<p>The head and tail of a non-empty array can be matched by using a cons pattern:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">add</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">arr</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">arr</span> <span class="kr">of</span>
  <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
  <span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">add</span> <span class="n">xs</span>
</pre></div>

<p><code>:</code> associates to the right:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">addPairs</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">arr</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">arr</span> <span class="kr">of</span>
  <span class="n">x</span> <span class="kt">:</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">addPairs</span> <span class="n">xs</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
</pre></div>

<h2>
<a name="record-patterns" class="anchor" href="#record-patterns"><span class="octicon octicon-link"></span></a>Record Patterns</h2>

<p>Record patterns match an input which is a record, and bring its properties into scope.</p>

<div class="highlight highlight-haskell"><pre><span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">o</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">o</span> <span class="kr">of</span>
  <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="s">"Foo"</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">bar</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
</pre></div>

<h2>
<a name="nested-patterns" class="anchor" href="#nested-patterns"><span class="octicon octicon-link"></span></a>Nested Patterns</h2>

<p>The patterns above can be combined to create larger patterns.</p>

<p>For example:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">o</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">o</span> <span class="kr">of</span>
  <span class="p">{</span> <span class="n">arr</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="kr">_</span><span class="p">,</span> <span class="n">take</span> <span class="ow">=</span> <span class="s">"car"</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="n">x</span>
  <span class="p">{</span> <span class="n">arr</span> <span class="ow">=</span> <span class="kr">_</span> <span class="kt">:</span> <span class="n">x</span> <span class="kt">:</span> <span class="kr">_</span><span class="p">,</span> <span class="n">take</span> <span class="ow">=</span> <span class="s">"cadr"</span> <span class="p">}</span> <span class="ow">-&gt;</span> <span class="n">x</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
</pre></div>

<h2>
<a name="named-patterns" class="anchor" href="#named-patterns"><span class="octicon octicon-link"></span></a>Named Patterns</h2>

<p>Named patterns bring additional names into scope when using nested patterns. Any pattern can be named by using the <code>@</code> symbol:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">arr</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">arr</span> <span class="kr">of</span>
  <span class="n">a</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span> <span class="kt">:</span> <span class="kr">_</span> <span class="kt">:</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">true</span>
  <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">false</span>
</pre></div>

<p>Here, in the first pattern, any array with two or more elements will be matched and bound to the variable <code>a</code>.</p>

<h2>
<a name="guards" class="anchor" href="#guards"><span class="octicon octicon-link"></span></a>Guards</h2>

<p>Guards are used to impose additional constraints inside a pattern using boolean-valued expressions, and are introduced with a pipe after the pattern:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">evens</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">arr</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">arr</span> <span class="kr">of</span> 
  <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="mi">0</span>
  <span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span> <span class="o">|</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">evens</span> <span class="n">xs</span>
  <span class="kr">_</span> <span class="kt">:</span> <span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">evens</span> <span class="n">xs</span>
</pre></div>

<p>When defining a function, guards appear after all patterns:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">greater</span> <span class="n">x</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">true</span>
<span class="nf">greater</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">false</span>
</pre></div>

<h2>
<a name="type-synonyms" class="anchor" href="#type-synonyms"><span class="octicon octicon-link"></span></a>Type Synonyms</h2>

<p>For convenience, it is possible to declare a synonym for a type using the <code>type</code> keyword. Type synonyms can include type arguments.</p>

<p>For example:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">type</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Number</span><span class="p">,</span> <span class="n">bar</span> <span class="kt">Number</span> <span class="p">}</span>

<span class="nf">addFoo</span> <span class="ow">::</span> <span class="kt">Foo</span> <span class="ow">-&gt;</span> <span class="kt">Number</span>
<span class="nf">addFoo</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">o</span> <span class="ow">-&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">bar</span>
</pre></div>

<h2>
<a name="record-updates" class="anchor" href="#record-updates"><span class="octicon octicon-link"></span></a>Record Updates</h2>

<p>Properties on records can be updated using the following syntax: <code>o { key = value, ..., key = value }</code></p>

<p>For example, the following function increments the <code>foo</code> property on its argument:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">incr</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">o</span> <span class="ow">-&gt;</span> <span class="n">o</span> <span class="p">{</span> <span class="n">foo</span> <span class="ow">=</span> <span class="n">o</span><span class="o">.</span><span class="n">foo</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</pre></div>

<p>The generated Javascript assumes the existence of a method called <code>Object.extend</code> such that <code>Object.extend(o, p)</code> takes an object <code>o</code> and generates a shallow copy of <code>o</code> including the properties of <code>p</code>. A simple JQuery implementation of this specification is</p>

<div class="highlight highlight-haskell"><pre><span class="kt">Object</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">extend</span> <span class="ow">=</span> <span class="n">function</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">return</span> <span class="o">$.</span><span class="n">extend</span><span class="p">({},</span> <span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>

<h2>
<a name="operators" class="anchor" href="#operators"><span class="octicon octicon-link"></span></a>Operators</h2>

<p>In addition to the standard operators, user-defined infix operators can be created by enclosing names in parentheses:</p>

<p>E.g. to create a synonym for string concatenation:</p>

<div class="highlight highlight-haskell"><pre><span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">s1</span> <span class="n">s2</span> <span class="ow">-&gt;</span> <span class="n">s1</span> <span class="o">++</span> <span class="n">s2</span>

<span class="nf">greeting</span> <span class="ow">=</span> <span class="s">"Hello"</span> <span class="o">&lt;&gt;</span> <span class="s">"World!"</span>
</pre></div>

<p>Regular functions can be used as operators by enclosing their names in backticks:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foo</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span>

<span class="nf">test</span> <span class="ow">=</span> <span class="mi">10</span> <span class="p">`</span><span class="n">foo</span><span class="p">`</span> <span class="mi">20</span>
</pre></div>

<p>Fixity declarations can associate a precedence level, which is a natural number, to a user-defined operator, and specify which way it associates:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">infixl</span> <span class="mi">5</span> <span class="o">&lt;&gt;</span>
<span class="kr">infixr</span> <span class="mi">7</span> <span class="o">%%</span>
</pre></div>

<h2>
<a name="modules" class="anchor" href="#modules"><span class="octicon octicon-link"></span></a>Modules</h2>

<p>Simple modules are supported by the <code>module</code> keyword.</p>

<p>Introduce a module as follows, with a list of indented declarations:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>

    <span class="n">foo</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span>
</pre></div>

<p>Modules may be nested:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">module</span> <span class="nn">A</span> <span class="kr">where</span>

    <span class="n">foo</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span>

    <span class="kr">module</span> <span class="nn">B</span> <span class="kr">where</span>

        <span class="n">bar</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">y</span>
</pre></div>

<p>Names may be qualified by using a dot:</p>

<pre><code>foo = A.foo
bar = A.B.bar
</code></pre>

<p>All the names in a module can be aliased using the <code>import</code> declaration:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">import</span> <span class="nn">A</span>
</pre></div>

<p>You can also limit which names are going to be aliased:</p>

<div class="highlight highlight-haskell"><pre><span class="kr">import</span> <span class="nn">A.B</span> <span class="p">(</span><span class="nf">bar</span><span class="p">)</span>
</pre></div>

<h2>
<a name="foreign-function-interface" class="anchor" href="#foreign-function-interface"><span class="octicon octicon-link"></span></a>Foreign Function Interface</h2>

<p>The <code>foreign import</code> keyword declares a value which is defined in Javascript, and its type:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">pow</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Number</span><span class="p">,</span> <span class="kt">Number</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Number</span>
</pre></div>

<p>To declare a new type with no constructors, use <code>foreign import data</code> and provide the kind:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">data</span> <span class="kt">IO</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">console</span> <span class="ow">::</span> <span class="p">{</span> 
  <span class="n">log</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">{}</span> 
<span class="p">}</span>
</pre></div>

<p>To alias a name of a field defined on a Javascript type to a PureScript function, use <code>foreign import member</code>. For example, to define a function <code>length</code> which accesses the <code>length</code> member of an array:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">member</span> <span class="s">"length"</span> <span class="n">length</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Number</span>
</pre></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Purescript maintained by <a href="https://github.com/paf31">paf31</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-33896432-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
