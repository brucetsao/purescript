{"name":"Purescript","tagline":"A small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks","body":"purescript\r\n==========\r\n\r\n[![Build Status](https://secure.travis-ci.org/paf31/purescript.png?branch=master)](http://travis-ci.org/paf31/purescript)\r\n\r\nA small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks\r\n\r\n## Current Features\r\n\r\n- Full Type Inference\r\n- Higher Kinded Polymorphism\r\n- Support for basic Javascript types\r\n- Extensible records\r\n- Type-safe blocks with for/while/assignment etc.\r\n- Functions with multiple arguments\r\n- Pattern matching\r\n- Simple FFI\r\n\r\n## Try It!\r\n\r\nTry PureScript in the browser [here](http://tryps.functorial.com/).\r\n\r\n## License\r\n\r\nSee the `LICENSE` file\r\n\r\n## Contributing\r\n\r\nContributions are always encouraged! Please see `CONTRIBUTING.md` for guidelines.\r\n\r\n## Installation\r\n\r\nInstall the Haskell Plaform, then `cabal install`\r\n\r\n## Usage\r\n\r\nThe `psc` executable takes a list of PureScript source files as arguments and by default writes out its errors or output to the console.\r\n\r\nThe following options are supported:\r\n\r\n    -o --output \r\n        Write the generated Javascript to the specified file\r\n        \r\n    -e --foreign imports\r\n        Write a list of foreign imports declarations to the specified file in addition to generating Javascript output\r\n\r\n## Motivation\r\n\r\nI was looking for a simple functional language which would compile to JavaScript and have the following characteristics:\r\n\r\n- Generate simple readable Javascript\r\n- Provide the ability to compile to tight loops if necessary\r\n- Reasonable type system\r\n- Ideally, written in a programming language I would enjoy working in\r\n- Provides a simple interface to existing Javascript code\r\n\r\nI didn't find exactly what I was looking for, so I wrote PureScript. It doesn't have everything right now, but it should serve as a simple core on which to develop new ideas.\r\n\r\nPureScript is *not* designed to be a general-purpose programming language. The primary use case is as a generator for purely-functional core libraries, with the main application code written in another language.\r\n\r\nPureScript can also be seen as a trade-off between a theoretically ideal language and one which generates reasonably high performance code.\r\n\r\n## Hello, PureScript!\r\n\r\nAs an introductory example, here is the usual \"Hello World\" written in PureScript:\r\n\r\n```haskell\r\nforeign import console :: { log :: String -> {} }\r\n\r\nmain = \\() -> console.log \"Hello, World!\"\r\n```\r\n\r\nwhich compiles to the following Javascript:\r\n\r\n```javascript\r\nfunction main() {\r\n    console.log(\"Hello, World!\");\r\n}\r\n```\r\n\r\n## Another Example\r\n\r\nThe following code defines a `Person` data type and a function to generate a string representation for a `Person`:\r\n\r\n```haskell\r\ndata Person = Person { name :: String, age :: Number }\r\n\r\nforeign import numberToString :: Number -> String\r\n\r\nshowPerson :: Person -> String\r\nshowPerson = \\p -> case p of\r\n  Person o -> o.name ++ \", aged \" ++ numberToString(o.age)\r\n```\r\n\r\nLine by line, this reads as follows:\r\n\r\n- `Person` is a data type with one constructor, also called `Person`\r\n    - The `Person` constructor takes an object with two properties, `name` which is a `String`, and `age` which is a `Number`\r\n- The `numberToString` function is written in Javascript, and converts a `Number` to its `String` representation\r\n- The `showPerson` function takes a `Person` and returns a `String`\r\n- `showPerson` works by case analysis on its argument `p`, first matching the constructor `Person` and then using string concatenation and object accessors to return its result.\r\n\r\nThe generated Javascript looks like this:\r\n\r\n```javascript\r\nvar Person = function (value) { \r\n  return { ctor: 'Person', value: value }; \r\n};\r\n\r\nfunction showPerson(p) {\r\n  if (p.ctor === \"Person\") {\r\n    return p.value.name + \", aged \" + itoa(p.value.age)\r\n  };\r\n  throw \"Failed pattern match\" \r\n}\r\n\r\n```\r\n\r\n## Type System\r\n\r\nThe type system defines the following types:\r\n\r\n- Primitive Types\r\n    - Number\r\n    - String\r\n    - Boolean\r\n- Arrays \r\n    - E.g. `[String]`, `[[Number]]`\r\n- Records\r\n    - E.g. `{ foo :: String, bar :: Number }`\r\n- Tagged Unions\r\n    - E.g. `data Foo a = Foo | Bar String`\r\n- Functions\r\n    - E.g. `Number -> String`\r\n    - E.g. `(Number, Number) -> Number`\r\n    - Functions can have zero or more arguments\r\n- Polymorphic types (for top level declarations only)\r\n    - E.g. `forall a. a -> a` \r\n\r\n## Primitive Types\r\n\r\nThe three primitive types `String`, `Number` and `Boolean` correspond to their Javascript equivalents at runtime.\r\n\r\nPureScript supports the same binary and unary operations on primitive types as Javascript, with the following exceptions:\r\n\r\n- String concatenation is denoted `++` to differentiate it from numeric addition, `+`\r\n- PureScript's `==` and `!=` correspond to Javascript's strong equality tests `===` and `!==`\r\n\r\nExamples:\r\n\r\n```haskell\r\nnum = 1 + 2 * 3\r\nstr = \"Hello, \" ++ \"World!\"\r\nbool = 1 > 2 || true\r\n```\r\n\r\n## Arrays\r\n\r\nPureScript arrays correspond to Javascript arrays at runtime, but all elements must have the same type.\r\n\r\nArray literals look like Javascript array literals: `[1, 2, 3]`\r\n\r\nArray elements can be read using array index notation `arr !! index`\r\n\r\n## Records\r\n\r\nPureScript records correspond to Javascript objects.\r\n\r\nRecord literals look like Javascript object literals: `{ foo: \"Foo\" }`\r\n\r\nProperties can be read by using dot notation: `o.foo`\r\n\r\n## Tagged Unions\r\n\r\nTagged unions consist of one or more constructors, each of which takes zero or one arguments.\r\n\r\nTagged unions can only be created using their constructors, and deconstructed through pattern matching (see later).\r\n\r\nFor example:\r\n\r\n```haskell\r\ndata Foo a = Foo | Bar String\r\n\r\nrunFoo = \\foo -> case foo of\r\nFoo -> \"It's a Foo\"\r\nBar s -> \"It's a Bar. The string is \" ++ s\r\n\r\nrunFoo Foo ++ runFoo (Bar \"Test\")\r\n```\r\n\r\nIn the example, Foo is a tagged union type which has two constructors. It's first constructor `Foo` takes no argument, and it's second `Bar` takes one, which must be a String.\r\n\r\n`runFoo` is an example of pattern matching on a tagged union type to discover its constructor, and the last line shows how `Foo`s are constructed.\r\n\r\n## Functions\r\n\r\nFunctions in PureScript can have zero or more arguments in general, just like in Javascript.\r\n\r\nFunctions are introduced by using a backslash followed by a list of argument names:\r\n\r\n```haskell\r\ntest1 = \\a b -> a + b\r\n```\r\n\r\nwhich would correspond to the Javascript \r\n\r\n```javascript\r\nfunction test1(a) {\r\n  return function (b) { \r\n    return a + b;\r\n  }\r\n}\r\n```\r\n\r\nMultiple argument functions can be introduced by wrapping the arguments in parentheses, and separating them with commas:\r\n\r\n```haskell\r\ntest1 = \\(a, b) -> a + b\r\n```\r\n\r\nwhich generates\r\n\r\n```javascript\r\nfunction test1(a, b) { \r\n  return a + b;\r\n}\r\n```\r\n    \r\nIn the case of a function with no arguments, the parentheses may be omitted, as follows:\r\n\r\n```haskell\r\ntest2 = \\ -> 100\r\n```\r\n\r\nwhich would correspond to the Javascript `function test2() { return 100; }`\r\n\r\nMultiple-argument and single-argument syntax can be mixed, as follows:\r\n\r\n```haskell\r\ntest3 = \\a (b, c) d -> a + b + c + d\r\n```\r\n\r\nwhich generates\r\n\r\n```javascript\r\nfunction test3(a) {\r\n    return function (b, c) {\r\n        return function (d) {\r\n            return a + b + c + d;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFunctions are applied by providing their arguments inside parentheses:\r\n\r\n```haskell\r\ntest1(1, 2, 3)\r\ntest2()\r\n```\r\n\r\nA special case is made in the case of functions with one argument. These functions can be applied without parentheses, and function application associates to the left:\r\n\r\n```haskell\r\n-- has type Number -> Number -> Number -> Number\r\naddThree = \\a b c -> a + b + c\r\n\r\n-- has type Number -> Number -> Number\r\naddThree 1 \r\n\r\n-- has type Number -> Number\r\naddThree 1 2 \r\n\r\n-- has type Number\r\naddThree 1 2 3 \r\n```\r\n\r\n## Polymorphic Types\r\n\r\nExpressions defined at the top level may have polymorphic types.\r\n\r\nHere is an example:\r\n\r\n```haskell\r\nidentity = \\x -> x\r\n```\r\n\r\n`identity` is inferred to have (polymorphic) type `forall t0. t0 -> t0`. This means that for any type `t0`, `identity` can be given a value of type `t0` and will give back a value of the same type.\r\n\r\nA type annotation can also be provided:\r\n\r\n```haskell\r\nidentity :: forall a. a -> a\r\nidentity = \\x -> x\r\n```\r\n\r\nFunctions may also be polymorphic in row types or type variables with other kinds (see \"Kind System\"):\r\n\r\n```haskell\r\naddProps = \\o -> o.foo + o.bar\r\n```\r\n    \r\nHere, `addProps` is inferred to have type `forall r. { foo :: Number, bar :: Number | r } -> Number`. That is, it can take any type which has properties `Foo` and `Bar`, and *any other record properties*.\r\n\r\nSo, the following compiles:\r\n\r\n```haskell\r\naddProps { foo: 1, bar: 2, baz: 3 }\r\n```\r\n    \r\nbut the following does not:\r\n\r\n```haskell\r\naddProps { foo: 1 }\r\n```\r\n    \r\nsince the `bar` property is missing.\r\n\r\nAgain, a type annotation can be provided if necessary.\r\n\r\n## Type Inference\r\n\r\nAll types can be inferred, but annotations can optionally be provided.\r\n\r\n## Kind System\r\n\r\nThere are two primitive kinds, the kind `*` of types and the kind `#` of rows. Higher kinded types are also supported. That is, a type variable can refer to not only a type or a row, but a type constructor, or row constructor etc.\r\n\r\n## Whitespace\r\n\r\nSyntax is whitespace sensitive. The general rule of thumb is that declarations which span multiple lines should be indented past the column on which they were first defined on their subsequent lines.\r\n\r\nThat is, the following is valid:\r\n\r\n```haskell\r\nfoo = bar(x) + \r\n  baz(x)\r\n```\r\n\r\nBut this is not:\r\n\r\n```haskell\r\nfoo = bar(x) + \r\nbaz(x)\r\n```\r\n\r\n## Do Notation\r\n\r\nThere is a keyword `do`, which does not have the same purpose as the `do` keyword in Haskell.\r\n\r\n`do` introduces a block. Blocks consist of statements, and must return a value of the same type on every branch of execution.\r\n\r\nThe following types of statement are supported:\r\n\r\n- Variable introduction\r\n- Variable assignment\r\n- For loops\r\n- For-each loops\r\n- While loops\r\n- If-Then-Else statements\r\n\r\nHere is an example of a power function defined using a block:\r\n\r\n```haskell\r\npow = \\n p -> do\r\n    var m = n\r\n\t  for i <- 0 until p:\r\n\t    m = m * n\r\n\t  return m\r\n```\r\n\r\nBlocks enable local mutation of their variables, but mutation is not allowed in general. The type system prevents mutable variables from escaping their scope.\r\n\r\nThat is, while the example above is valid, the following does not compile:\r\n\r\n```haskell\r\nincr = \\n -> do\r\n  n = n + 1 \r\n  return n\r\n```\r\n\r\nThe variable `n` is not mutable, and so the assignment in the first line of the `do` block is not allowed.\r\n\r\nThis function can be rewritten as follows:\r\n\r\n```haskell\r\nincr = \\n -> do\r\n  var m = n\r\n  m = m + 1 \r\n  return m\r\n```\r\n\r\n## For Loops\r\n\r\nFor loops look like this:\r\n\r\n```haskell\r\ntotal = do\r\n  var n = 0\r\n  for i <- 0 until 10:\r\n  n = n + i\r\n  return n\r\n```\r\n\r\nThe bounds `0` and `10` are inclusive and exclusive respectively.\r\n      \r\n## For-Each Loops\r\n\r\nFor each loops loop over the elements in an array using the `Object.forEach` method. A polyfill may be required for some browsers:\r\n\r\n```haskell\r\ntotal = \\arr -> do\r\n  var n = 0\r\n  foreach i in arr:\r\n    n = n + i\r\n  return n\r\n```\r\n\r\n## While Loops\r\n\r\nThe syntax of a while loop is similar to a foreach loop:\r\n\r\n```haskell\r\nlog2 = \\n -> do\r\n  var count = 0\r\n  var m = n\r\n  while m > 1:\r\n    m = m / 2\r\n    count = count + 1\r\n  return count\r\n```\r\n\r\n## If-Then-Else Statements\r\n\r\nElse branches are optional, and may contain further `if` statements, just as in Javascript:\r\n\r\n```haskell\r\ncollatz = \\n -> do\r\n  var count = 0\r\n  var m = n\r\n  while m > 1:\r\n    if m % 2 == 0:\r\n      m = m / 2\r\n    else:\r\n      m = m * 3 + 1\r\n    count = count + 1\r\n  return count\r\n```\r\n      \r\n## If-Then-Else Expressions\r\n\r\nThe `if`, `then` and `else` keywords can also be used to create conditional expressions. In this case, the `else` block is always required.\r\n\r\nFor example,\r\n\r\n```haskell\r\nconditional = if 2 > 1 then \"ok\" else \"oops\"\r\n```\r\n\r\n## Pattern Matching\r\n\r\nPattern matching deconstructs a value to bring zero or more expressions into scope. Pattern matches are introduced with the `case` keyword.\r\n\r\nPattern matches have the following general form\r\n\r\n```haskell\r\ncase value of\r\n  pattern -> result\r\n  -- ...\r\n  pattern -> result\r\n```\r\n\r\nThe following pattern types are supported:\r\n\r\n- Wildcard pattern\r\n- Literal patterns\r\n- Variable pattern\r\n- Array patterns\r\n- Record patterns\r\n- Named patterns\r\n- Guards\r\n\r\nPatterns need not be exhaustive. A pattern match failed exception will be thrown at runtime if no pattern matches the input.\r\n\r\n## Wildcard Patterns\r\n\r\nThe wilcard `_` matches any input and brings nothing into scope:\r\n\r\n```haskell\r\ncase x of \r\n  _ -> 0\r\n```\r\n      \r\n## Literal Patterns\r\n\r\nLiteral patterns are provided to match on primitives:\r\n\r\n```haskell\r\ncase booleanValue of \r\n  true -> 0\r\n  false -> 1\r\n  \r\ncase stringValue of \r\n  \"Foo\" -> 0\r\n  _ -> 1\r\n  \r\ncase numericValue of \r\n  0 -> 0\r\n  _ -> 1\r\n```\r\n\r\n## Variable Pattern\r\n\r\nA variable pattern matches any input and binds that input to its name:\r\n\r\n```haskell\r\ncase foo(x) of\r\n  result -> bar(result)\r\n```\r\n\r\n## Array Patterns\r\n\r\nArray patterns match an input which is an array, and bring its elements into scope.\r\n\r\nFor example:\r\n\r\n```haskell\r\nf = \\arr -> case arr of\r\n  [x] -> x\r\n  [x, y : xs] -> x * y + f(xs)\r\n  _ -> 0\r\n```\r\n\r\nHere, the first pattern only matches arrays of length one, and brings the first element of the array into scope.\r\n\r\nThe second pattern matches arrays with two or more elements, and brings the first and second elements into scope, along with the remainder of the array as the variable `xs`.\r\n\r\n## Record Patterns\r\n\r\nRecord patterns match an input which is a record, and bring its properties into scope.\r\n\r\n```haskell\r\nf = \\o -> case o of\r\n  { foo = \"Foo\" } -> o.bar\r\n  _ -> 0\r\n```\r\n\r\n## Nested Patterns\r\n\r\nThe patterns above can be combined to create larger patterns.\r\n\r\nFor example:\r\n\r\n```haskell\r\nf = \\o -> case o of\r\n  { arr = [x:_], take = \"car\" } -> x\r\n  { arr = [_,x:_], take = \"cadr\" } -> x\r\n  _ -> 0\r\n```\r\n\r\n## Named Patterns\r\n\r\nNamed patterns bring additional names into scope when using nested patterns. Any pattern can be named by using the `@` symbol:\r\n\r\n```haskell\r\nf = \\arr -> case arr of\r\n  a@[_,_:_] -> a\r\n  a -> a\r\n```\r\n     \r\nHere, in the first pattern, any array with two or more elements will be matched and bound to the variable `a`.\r\n\r\n## Guards\r\n\r\nGuards are used to impose additional constraints inside a pattern using boolean-valued expressions, and are introduced with a pipe after the pattern:\r\n\r\n```haskell\r\nevens = \\arr -> case arr of \r\n  [] -> 0\r\n  [x:xs] | x % 2 == 0 -> 1 + evens xs\r\n  [_:xs] -> evens xs\r\n```\r\n\r\n## Type Synonyms\r\n\r\nFor convenience, it is possible to declare a synonym for a type using the `type` keyword. Type synonyms can include type arguments.\r\n\r\nFor example:\r\n\r\n```haskell\r\ntype Foo = { foo :: Number, bar Number }\r\n\r\naddFoo :: Foo -> Number\r\naddFoo = \\o -> o.foo + o.bar\r\n```\r\n## Record Updates\r\n\r\nProperties on records can be updated using the following syntax: `o { key = value, ..., key = value }`\r\n\r\nFor example, the following function increments the `foo` property on its argument:\r\n\r\n```haskell\r\nincr = \\o -> o { foo = o.foo + 1 }\r\n```\r\n\r\nThe generated Javascript assumes the existence of a method called `Object.extend` such that `Object.extend(o, p)` takes an object `o` and generates a shallow copy of `o` including the properties of `p`. A simple JQuery implementation of this specification is\r\n\r\n```haskell\r\nObject.prototype.extend = function(o, p) {\r\n    return $.extend({}, o, p);\r\n};\r\n```\r\n\r\n## Operators\r\n\r\nIn addition to the standard operators, user-defined infix operators can be created by enclosing names in parentheses:\r\n\r\nE.g. to create a synonym for string concatenation:\r\n\r\n```haskell\r\n(<>) = \\s1 s2 -> s1 ++ s2\r\n\r\ngreeting = \"Hello\" <> \"World!\"\r\n```\r\n\r\nRegular functions can be used as operators by enclosing their names in backticks:\r\n\r\n```haskell\r\nfoo = \\x y -> x * y + y\r\n\r\ntest = 10 `foo` 20\r\n```\r\n    \r\nFixity declarations can associate a precedence level, which is a natural number, to a user-defined operator, and specify which way it associates:\r\n\r\n```haskell\r\ninfixl 5 <>\r\ninfixr 7 %%\r\n```\r\n\r\n## Modules\r\n\r\nSimple modules are supported by the `module` keyword.\r\n\r\nIntroduce a module as follows, with a list of indented declarations:\r\n\r\n```haskell\r\nmodule A where\r\n\r\n    foo = \\x -> x\r\n```\r\n\r\nModules may be nested:\r\n\r\n```haskell\r\nmodule A where\r\n\r\n    foo = \\x -> x\r\n    \r\n    module B where\r\n    \r\n        bar = \\y -> y\r\n```\r\n\r\nNames may be qualified by using a colon:\r\n\r\n```\r\nfoo = A:foo\r\nbar = A:B:bar\r\n```\r\n\r\n## Foreign Function Interface\r\n\r\nThe `foreign import` keyword declares a value which is defined in Javascript, and its type:\r\n\r\n```haskell\r\nforeign import pow :: (Number, Number) -> Number\r\n```\r\n\r\nTo declare a new type with no constructors, use `foreign import data` and provide the kind:\r\n\r\n```haskell\r\nforeign import data IO :: * -> *\r\n\t\r\nforeign import console :: { \r\n  log :: String -> IO {} \r\n}\r\n```\r\n\r\nTo alias a name of a field defined on a Javascript type to a PureScript function, use `foreign import member`. For example, to define a function `length` which accesses the `length` member of an array:\r\n\r\n```haskell\r\nforeign import member \"length\" length :: forall a. [a] -> Number\r\n```\r\n\r\n\r\n","google":"UA-33896432-1","note":"Don't delete this file! It's used internally to help with page regeneration."}