{"name":"Purescript","tagline":"A small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks","body":"purescript\r\n==========\r\n\r\n[![Build Status](https://secure.travis-ci.org/paf31/purescript.png?branch=master)](http://travis-ci.org/paf31/purescript)\r\n\r\nA small strongly, statically typed compile-to-JS language with basic extensible records and type-safe blocks\r\n\r\nBitcoin donations are gratefully accepted at 14ZhCym28WDuFhocP44tU1dBpCzjX1DvhF.\r\n\r\n## Current Features\r\n\r\n- Full Type Inference\r\n- Higher Kinded Polymorphism\r\n- Support for basic Javascript types\r\n- Extensible records\r\n- Type-safe blocks with for/while/assignment etc.\r\n- Functions with multiple arguments\r\n- Pattern matching\r\n- Simple FFI\r\n- Modules\r\n- Rank N Types\r\n- Do Notation\r\n- Optional tail-call elimination\r\n\r\n## Try It!\r\n\r\nTry PureScript in the browser [here](http://tryps.functorial.com/).\r\n\r\n## License\r\n\r\nSee the `LICENSE` file\r\n\r\n## Contributing\r\n\r\nContributions are always encouraged! Please see `CONTRIBUTING.md` for guidelines.\r\n\r\nJoin the discussion on FreeNode at [irc://irc.freenode.net/#purescript](irc://irc.freenode.net/#purescript).\r\n\r\n## Installation\r\n\r\nInstall the Haskell Plaform, then `cabal install`\r\n\r\n## Usage\r\n\r\nThe `psc` executable takes a list of PureScript source files as arguments and by default writes out its errors or output to the console.\r\n\r\nThe following options are supported:\r\n\r\n    -s --stdin\r\n        Read input from standard input instead of from files\r\n    \r\n    -o --output \r\n        Write the generated Javascript to the specified file\r\n        \r\n    -e --foreign imports\r\n        Write a list of foreign imports declarations to the specified file in addition to generating Javascript output\r\n        \r\n    --runtime-type-checks\r\n        Generate simple runtime type checks for function arguments with simple types.\r\n        \r\n    --tco\r\n        Perform tail-call elimination on the generated Javascript.\r\n        \r\n    --no-prelude\r\n        Do not include the Prelude in the generated Javascript.\r\n        \r\n    --magic-do\r\n        Overload the `do` keyword to inline calls to `bind` for the `Eff` monad, to generate more efficient code.\r\n\r\n    --run-main\r\n        Generate a call to `Main.main` after all other generated Javascript.\r\n\r\n## Motivation\r\n\r\nI was looking for a simple functional language which would compile to JavaScript and have the following characteristics:\r\n\r\n- Generate simple readable Javascript\r\n- Provide the ability to compile to tight loops if necessary\r\n- Reasonable type system\r\n- Ideally, written in a programming language I would enjoy working in\r\n- Provides a simple interface to existing Javascript code\r\n\r\nI didn't find exactly what I was looking for, so I wrote PureScript. It doesn't have everything right now, but it should serve as a simple core on which to develop new ideas.\r\n\r\nPureScript is *not* designed to be a general-purpose programming language. The primary use case is as a generator for purely-functional core libraries, with the main application code written in another language.\r\n\r\nPureScript can also be seen as a trade-off between a theoretically ideal language and one which generates reasonably high performance code.\r\n\r\n## Hello, PureScript!\r\n\r\nAs an introductory example, here is the usual \"Hello World\" written in PureScript:\r\n\r\n```haskell\r\nmodule Main where\r\n\r\nforeign import console :: { log :: String -> {} }\r\n\r\nmain = \\ -> console.log \"Hello, World!\"\r\n```\r\n\r\nwhich compiles to the following Javascript:\r\n\r\n```javascript\r\nvar Main; \r\n(function (Main) {\r\n    function main() {\r\n        return console.log(\"Hello, World!\"); \r\n    }; \r\n    Main.main = main; \r\n})(Main = Main || {});\r\n```\r\n\r\n## Another Example\r\n\r\nThe following code defines a `Person` data type and a function to generate a string representation for a `Person`:\r\n\r\n```haskell\r\ndata Person = Person { name :: String, age :: Number }\r\n\r\nforeign import numberToString :: Number -> String\r\n\r\nshowPerson :: Person -> String\r\nshowPerson (Person o) = o.name ++ \", aged \" ++ numberToString(o.age)\r\n```\r\n\r\nLine by line, this reads as follows:\r\n\r\n- `Person` is a data type with one constructor, also called `Person`\r\n    - The `Person` constructor takes an object with two properties, `name` which is a `String`, and `age` which is a `Number`\r\n- The `numberToString` function is written in Javascript, and converts a `Number` to its `String` representation\r\n- The `showPerson` function takes a `Person` and returns a `String`\r\n- `showPerson` works by case analysis on its argument, first matching the constructor `Person` and then using string concatenation and object accessors to return its result.\r\n\r\nThe generated Javascript looks like this:\r\n\r\n```javascript\r\nvar Person = function (value) { \r\n    return { ctor: 'Person', value: value }; \r\n};\r\n\r\nfunction showPerson(_1) {\r\n    if (_1.ctor === \"Person\") {\r\n        return _1.value.name + \", aged \" + numberToString(_1.value.age); \r\n    }; \r\n    throw \"Failed pattern match\"; \r\n}; \r\n\r\n```\r\n\r\n## Type System\r\n\r\nThe type system defines the following types:\r\n\r\n- Primitive Types\r\n    - Number\r\n    - String\r\n    - Boolean\r\n- Arrays \r\n    - E.g. `[String]`, `[[Number]]`\r\n- Records\r\n    - E.g. `{ foo :: String, bar :: Number }`\r\n- Tagged Unions\r\n    - E.g. `data Foo a = Foo | Bar String`\r\n- Functions\r\n    - E.g. `Number -> String`\r\n    - E.g. `(Number, Number) -> Number`\r\n    - Functions can have zero or more arguments\r\n- Polymorphic types\r\n    - E.g. `forall a. a -> a` \r\n\r\n## Primitive Types\r\n\r\nThe three primitive types `String`, `Number` and `Boolean` correspond to their Javascript equivalents at runtime.\r\n\r\nPureScript supports the same binary and unary operations on primitive types as Javascript, with the following exceptions:\r\n\r\n- String concatenation is denoted `++` to differentiate it from numeric addition, `+`\r\n- PureScript's `==` and `!=` correspond to Javascript's strong equality tests `===` and `!==`\r\n\r\nExamples:\r\n\r\n```haskell\r\nnum = 1 + 2 * 3\r\nstr = \"Hello, \" ++ \"World!\"\r\nbool = 1 > 2 || true\r\n```\r\n\r\n## Arrays\r\n\r\nPureScript arrays correspond to Javascript arrays at runtime, but all elements must have the same type.\r\n\r\nArray literals look like Javascript array literals: `[1, 2, 3]`\r\n\r\nArray elements can be read using array index notation `arr !! index`\r\n\r\n## Records\r\n\r\nPureScript records correspond to Javascript objects.\r\n\r\nRecord literals look like Javascript object literals: `{ foo: \"Foo\" }`\r\n\r\nProperties can be read by using dot notation: `o.foo`\r\n\r\n## Tagged Unions\r\n\r\nTagged unions consist of one or more constructors, each of which takes zero or one arguments.\r\n\r\nTagged unions can only be created using their constructors, and deconstructed through pattern matching (see later).\r\n\r\nFor example:\r\n\r\n```haskell\r\ndata Foo a = Foo | Bar String\r\n\r\nrunFoo Foo = \"It's a Foo\"\r\nrunFoo (Bar s) = \"It's a Bar. The string is \" ++ s\r\n\r\ntest = runFoo Foo ++ runFoo (Bar \"Test\")\r\n```\r\n\r\nIn the example, Foo is a tagged union type which has two constructors. It's first constructor `Foo` takes no argument, and it's second `Bar` takes one, which must be a String.\r\n\r\n`runFoo` is an example of pattern matching on a tagged union type to discover its constructor, and the last line shows how `Foo`s are constructed.\r\n\r\n## Functions\r\n\r\nFunctions in PureScript can have zero or more arguments in general, just like in Javascript.\r\n\r\nFunctions are introduced by using a backslash followed by a list of argument names:\r\n\r\n```haskell\r\ntest1 = \\a b -> a + b\r\n```\r\n\r\nwhich would correspond to the Javascript \r\n\r\n```javascript\r\nfunction test1(a) {\r\n  return function (b) { \r\n    return a + b;\r\n  }\r\n}\r\n```\r\n\r\nMultiple argument functions can be introduced by wrapping the arguments in parentheses, and separating them with commas:\r\n\r\n```haskell\r\ntest1 = \\(a, b) -> a + b\r\n```\r\n\r\nwhich generates\r\n\r\n```javascript\r\nfunction test1(a, b) { \r\n  return a + b;\r\n}\r\n```\r\n    \r\nIn the case of a function with no arguments, the parentheses may be omitted, as follows:\r\n\r\n```haskell\r\ntest2 = \\ -> 100\r\n```\r\n\r\nwhich would correspond to the Javascript `function test2() { return 100; }`\r\n\r\nMultiple-argument and single-argument syntax can be mixed, as follows:\r\n\r\n```haskell\r\ntest3 = \\a (b, c) d -> a + b + c + d\r\n```\r\n\r\nwhich generates\r\n\r\n```javascript\r\nfunction test3(a) {\r\n    return function (b, c) {\r\n        return function (d) {\r\n            return a + b + c + d;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nFunctions are applied by providing their arguments inside parentheses:\r\n\r\n```haskell\r\ntest1(1, 2, 3)\r\ntest2()\r\n```\r\n\r\nA special case is made in the case of functions with one argument. These functions can be applied without parentheses, and function application associates to the left:\r\n\r\n```haskell\r\n-- has type Number -> Number -> Number -> Number\r\naddThree = \\a b c -> a + b + c\r\n\r\n-- has type Number -> Number -> Number\r\naddThree 1 \r\n\r\n-- has type Number -> Number\r\naddThree 1 2 \r\n\r\n-- has type Number\r\naddThree 1 2 3 \r\n```\r\n\r\n## Polymorphic Types\r\n\r\nExpressions defined at the top level may have polymorphic types.\r\n\r\nHere is an example:\r\n\r\n```haskell\r\nidentity x = x\r\n```\r\n\r\n`identity` is inferred to have (polymorphic) type `forall t0. t0 -> t0`. This means that for any type `t0`, `identity` can be given a value of type `t0` and will give back a value of the same type.\r\n\r\nA type annotation can also be provided:\r\n\r\n```haskell\r\nidentity :: forall a. a -> a\r\nidentity x = x\r\n```\r\n\r\nFunctions may also be polymorphic in row types or type variables with other kinds (see \"Kind System\"):\r\n\r\n```haskell\r\naddProps o = o.foo + o.bar\r\n```\r\n    \r\nHere, `addProps` is inferred to have type `forall r. { foo :: Number, bar :: Number | r } -> Number`. That is, it can take any type which has properties `Foo` and `Bar`, and *any other record properties*.\r\n\r\nSo, the following compiles:\r\n\r\n```haskell\r\naddProps { foo: 1, bar: 2, baz: 3 }\r\n```\r\n    \r\nbut the following does not:\r\n\r\n```haskell\r\naddProps { foo: 1 }\r\n```\r\n    \r\nsince the `bar` property is missing.\r\n\r\nAgain, a type annotation can be provided if necessary.\r\n\r\n## Rank N Types\r\n\r\nIt is also possible for the `forall` quantifier to appear on the left of a function arrow, inside types record fields and data constructors, and in type synonyms.\r\n\r\nIn most cases, a type annotation is necessary when using this feature.\r\n\r\nAs an example, we can pass a polymorphic function as an argument to another function:\r\n\r\n```haskell\r\npoly :: (forall a. a -> a) -> Boolean\r\npoly f = (f 0 < 1) == f true\r\n```\r\n\r\nNotice that the polymorphic function's type argument is instantiated to both `Number` and `Boolean`.\r\n\r\nAn argument to `poly` must indeed be polymorphic. For example, the following fails:\r\n\r\n```haskell\r\ntest = poly (\\n -> n + 1)\r\n```\r\n\r\nsince the skolemized type variable `a` does not unify with `Number`.\r\n\r\n## Type Inference\r\n\r\nAll types can be inferred, but annotations can optionally be provided.\r\n\r\n## Kind System\r\n\r\nThere are two primitive kinds, the kind `*` of types and the kind `!` of effects. \r\n\r\nFor each kind `k` there is also a kind `# k` of rows, with types of kind `k`. For example `# *` is the kind of rows of types, as used to define records, and `# !` is the kind of rows of effects, used to define the monad `Eff` of extensible effects.\r\n\r\nHigher kinded types are also supported. That is, a type variable can refer to not only a type or a row, but a type constructor, or row constructor etc.\r\n\r\n## Whitespace\r\n\r\nSyntax is whitespace sensitive. The general rule of thumb is that declarations which span multiple lines should be indented past the column on which they were first defined on their subsequent lines.\r\n\r\nThat is, the following is valid:\r\n\r\n```haskell\r\nfoo = bar(x) + \r\n  baz(x)\r\n```\r\n\r\nBut this is not:\r\n\r\n```haskell\r\nfoo = bar(x) + \r\nbaz(x)\r\n```\r\n\r\n## Blocks\r\n\r\nBlocks are collections of statements wrapped in braces `{ ... }`. Blocks must return a value of the same type on every branch of execution.\r\n\r\nThe following types of statement are supported:\r\n\r\n- Variable introduction\r\n- Variable assignment\r\n- For loops\r\n- For-each loops\r\n- While loops\r\n- If-Then-Else statements\r\n\r\nHere is an example of a power function defined using a block:\r\n\r\n```haskell\r\npow n p = {\r\n    var m = n;\r\n    for (i <- 0 until p) {\r\n      m = m * n;\r\n    }\r\n    return m;\r\n  }\r\n```\r\n\r\nBlocks enable local mutation of their variables, but mutation is not allowed in general. The type system prevents mutable variables from escaping their scope.\r\n\r\nThat is, while the example above is valid, the following does not compile:\r\n\r\n```haskell\r\nincr n = {\r\n    n = n + 1;\r\n    return n;\r\n  }\r\n```\r\n\r\nThe variable `n` is not mutable, and so the assignment in the first line of the `do` block is not allowed.\r\n\r\nThis function can be rewritten as follows:\r\n\r\n```haskell\r\nincr n = {\r\n    var m = n;\r\n    m = m + 1;\r\n    return m;\r\n  }\r\n```\r\n\r\n## For Loops\r\n\r\nFor loops look like this:\r\n\r\n```haskell\r\ntotal = {\r\n    var n = 0;\r\n    for (i <- 0 until 10) {\r\n      n = n + i;\r\n    }\r\n    return n;\r\n  }\r\n```\r\n\r\nThe bounds `0` and `10` are inclusive and exclusive respectively.\r\n      \r\n## For-Each Loops\r\n\r\nFor each loops loop over the elements in an array using the `Object.forEach` method. A polyfill may be required for some browsers:\r\n\r\n```haskell\r\ntotal arr = {\r\n    var n = 0;\r\n    foreach (i in arr) {\r\n      n = n + i;\r\n    }\r\n    return n;\r\n  }\r\n```\r\n\r\n## While Loops\r\n\r\nThe syntax of a while loop is similar to a foreach loop:\r\n\r\n```haskell\r\nlog2 n = {\r\n    var count = 0;\r\n    var m = n;\r\n    while (m > 1) {\r\n      m = m / 2;\r\n      count = count + 1;\r\n    }\r\n    return count;\r\n  }\r\n```\r\n\r\n## If-Then-Else Statements\r\n\r\nElse branches are optional, and may contain further `if` statements, just as in Javascript:\r\n\r\n```haskell\r\ncollatz n = {\r\n    var count = 0;\r\n    var m = n;\r\n    while (m > 1) {\r\n      if (m % 2 == 0) {\r\n        m = m / 2;\r\n      } else {\r\n        m = m * 3 + 1;\r\n      }\r\n      count = count + 1;\r\n    }\r\n    return count;\r\n  }\r\n```\r\n      \r\n## If-Then-Else Expressions\r\n\r\nThe `if`, `then` and `else` keywords can also be used to create conditional expressions. In this case, the `else` block is always required.\r\n\r\nFor example,\r\n\r\n```haskell\r\nconditional = if 2 > 1 then \"ok\" else \"oops\"\r\n```\r\n\r\n## Do Notation\r\n\r\nThe `do` keyword introduces simple syntactic sugar for monadic expressions.\r\n\r\nHere is an example, using the maybe monad:\r\n\r\n```haskell\r\ndata Maybe a = Nothing | Just a\r\n\r\nbindMaybe Nothing _ = Nothing\r\nbindMaybe (Just a) f = f a\r\n\r\nmaybe = { ret: Just, bind: bindMaybe }\r\n\r\nisEven n | n % 2 == 0 = Just {}\r\nisEven _ = Nothing\r\n\r\nevenSum a b = maybe do\r\n  n <- a\r\n  m <- b\r\n  let sum = n + m\r\n  isEven sum\r\n  return sum\r\n```\r\n\r\n`isEven` adds two values of type `Maybe Number` and returns their sum, if the sum is even. If the sum is odd, `evenSum` returns `Nothing`.\r\n\r\nThis example illustrates the following aspects of `do` notation:\r\n\r\n- The `do` keyword is preceded by a value `m` which is a record. The record must contain fields `ret` and `bind` which determine the monad which will be used in the computation.\r\n- Statements can have the following form:\r\n    - `a <- x` which desugars to `m.bind x (\\a -> ...)` \r\n    - `let a = x` which desugars to `(\\a -> ...)(x)` \r\n    - `return a` which desugars to `m.ret a`\r\n    - `x` which desugars to `m.bind x (\\_ -> ...)` or just `x` if this is the last statement.\r\n\r\nNot illustrated here, but equally valid is the use of a binder on the left hand side of `<-` or `=`. For example:\r\n\r\n```haskell\r\ntest arr = maybe do\r\n  (x:y:_) <- arr\r\n  return x + y\r\n```\r\n\r\nA pattern match failure will generate a runtime exception, just as in the case of a regular `case` statement.\r\n\r\n## Pattern Matching\r\n\r\nPattern matching deconstructs a value to bring zero or more expressions into scope. Pattern matches are introduced with the `case` keyword.\r\n\r\nPattern matches have the following general form\r\n\r\n```haskell\r\ncase value of\r\n  pattern -> result\r\n  -- ...\r\n  pattern -> result\r\n```\r\n\r\nPattern matching can also be used in the declaration of functions, as we have already seen:\r\n\r\n```haskell\r\nfn pattern_1 ... pattern_n = result\r\n```\r\n\r\nAny of the above types of pattern are also valid when introducing functions. In addition, patterns can also be grouped in parentheses to introduce multiple-arugument functions. For example, \r\n\r\n```haskell\r\nexample x (y, z) w = x * y + z * w\r\n```\r\n\r\nThe following pattern types are supported:\r\n\r\n- Wildcard pattern\r\n- Literal patterns\r\n- Variable pattern\r\n- Array patterns\r\n- Cons patterns\r\n- Record patterns\r\n- Named patterns\r\n- Guards\r\n\r\nPatterns need not be exhaustive. A pattern match failed exception will be thrown at runtime if no pattern matches the input.\r\n\r\n## Wildcard Patterns\r\n\r\nThe wilcard `_` matches any input and brings nothing into scope:\r\n\r\n```haskell\r\ncase x of \r\n  _ -> 0\r\n```\r\n      \r\n## Literal Patterns\r\n\r\nLiteral patterns are provided to match on primitives:\r\n\r\n```haskell\r\ncase booleanValue of \r\n  true -> 0\r\n  false -> 1\r\n  \r\ncase stringValue of \r\n  \"Foo\" -> 0\r\n  _ -> 1\r\n  \r\ncase numericValue of \r\n  0 -> 0\r\n  _ -> 1\r\n```\r\n\r\n## Variable Pattern\r\n\r\nA variable pattern matches any input and binds that input to its name:\r\n\r\n```haskell\r\ncase foo(x) of\r\n  result -> bar(result)\r\n```\r\n\r\n## Array Patterns\r\n\r\nArray patterns match an input which is an array, and bring its elements into scope.\r\n\r\nFor example:\r\n\r\n```haskell\r\nf = \\arr -> case arr of\r\n  [x] -> x\r\n  [x, y] -> x * y + f xs\r\n  _ -> 0\r\n```\r\n\r\nHere, the first pattern only matches arrays of length one, and brings the first element of the array into scope.\r\n\r\nThe second pattern matches arrays with two elements, and brings the first and second elements into scope.\r\n\r\n## Cons Patterns\r\n\r\nThe head and tail of a non-empty array can be matched by using a cons pattern:\r\n\r\n```haskell\r\nadd = \\arr -> case arr of\r\n  [] -> 0\r\n  x : xs -> x + add xs\r\n```\r\n\r\n`:` associates to the right:\r\n\r\n```haskell\r\naddPairs = \\arr -> case arr of\r\n  x : y : xs -> x * y + addPairs xs\r\n  _ -> 0\r\n```\r\n\r\n## Record Patterns\r\n\r\nRecord patterns match an input which is a record, and bring its properties into scope.\r\n\r\n```haskell\r\nf = \\o -> case o of\r\n  { foo = \"Foo\" } -> o.bar\r\n  _ -> 0\r\n```\r\n\r\n## Nested Patterns\r\n\r\nThe patterns above can be combined to create larger patterns.\r\n\r\nFor example:\r\n\r\n```haskell\r\nf = \\o -> case o of\r\n  { arr = x : _, take = \"car\" } -> x\r\n  { arr = _ : x : _, take = \"cadr\" } -> x\r\n  _ -> 0\r\n```\r\n\r\n## Named Patterns\r\n\r\nNamed patterns bring additional names into scope when using nested patterns. Any pattern can be named by using the `@` symbol:\r\n\r\n```haskell\r\nf = \\arr -> case arr of\r\n  a@(_ : _ : _) -> true\r\n  a -> false\r\n```\r\n     \r\nHere, in the first pattern, any array with two or more elements will be matched and bound to the variable `a`.\r\n\r\n## Guards\r\n\r\nGuards are used to impose additional constraints inside a pattern using boolean-valued expressions, and are introduced with a pipe after the pattern:\r\n\r\n```haskell\r\nevens = \\arr -> case arr of \r\n  [] -> 0\r\n  x : xs | x % 2 == 0 -> 1 + evens xs\r\n  _ : xs -> evens xs\r\n```\r\n\r\nWhen defining a function, guards appear after all patterns:\r\n\r\n```haskell\r\ngreater x y | x > y = true\r\ngreater _ _ = false\r\n```\r\n\r\n## Type Synonyms\r\n\r\nFor convenience, it is possible to declare a synonym for a type using the `type` keyword. Type synonyms can include type arguments.\r\n\r\nFor example:\r\n\r\n```haskell\r\ntype Foo = { foo :: Number, bar Number }\r\n\r\naddFoo :: Foo -> Number\r\naddFoo = \\o -> o.foo + o.bar\r\n```\r\n## Record Updates\r\n\r\nProperties on records can be updated using the following syntax: `o { key = value, ..., key = value }`\r\n\r\nFor example, the following function increments the `foo` property on its argument:\r\n\r\n```haskell\r\nincr = \\o -> o { foo = o.foo + 1 }\r\n```\r\n\r\nThe generated Javascript assumes the existence of a method called `Object.extend` such that `Object.extend(o, p)` takes an object `o` and generates a shallow copy of `o` including the properties of `p`. A simple JQuery implementation of this specification is\r\n\r\n```haskell\r\nObject.prototype.extend = function(o, p) {\r\n    return $.extend({}, o, p);\r\n};\r\n```\r\n\r\n## Operators\r\n\r\nIn addition to the standard operators, user-defined infix operators can be created by enclosing names in parentheses:\r\n\r\nE.g. to create a synonym for string concatenation:\r\n\r\n```haskell\r\n(<>) = \\s1 s2 -> s1 ++ s2\r\n\r\ngreeting = \"Hello\" <> \"World!\"\r\n```\r\n\r\nRegular functions can be used as operators by enclosing their names in backticks:\r\n\r\n```haskell\r\nfoo = \\x y -> x * y + y\r\n\r\ntest = 10 `foo` 20\r\n```\r\n    \r\nFixity declarations can associate a precedence level, which is a natural number, to a user-defined operator, and specify which way it associates:\r\n\r\n```haskell\r\ninfixl 5 <>\r\ninfixr 7 %%\r\n```\r\n\r\n## Modules\r\n\r\nModules are introduced using the `module` keyword. All code must be placed in a module.\r\n\r\nIntroduce a module as follows, with a list of declarations:\r\n\r\n```haskell\r\nmodule A where\r\n\r\nid x = x\r\n```\r\n\r\nNames may be qualified by using a dot:\r\n\r\n```\r\nfoo = A.foo\r\nbar = A.B.bar\r\n```\r\n\r\nAll the names in a module can be aliased using the `import` declaration:\r\n\r\n```haskell\r\nimport A\r\n```\r\n\r\nYou can also limit which names are going to be aliased:\r\n\r\n```haskell\r\nimport A.B (bar)\r\n```\r\n\r\n## Foreign Function Interface\r\n\r\nThe `foreign import` keyword declares a value which is defined in Javascript, and its type:\r\n\r\n```haskell\r\nforeign import pow :: (Number, Number) -> Number\r\n```\r\n\r\nTo declare a new type with no constructors, use `foreign import data` and provide the kind:\r\n\r\n```haskell\r\nforeign import data IO :: * -> *\r\n\t\r\nforeign import console :: { \r\n  log :: String -> IO {} \r\n}\r\n```\r\n\r\nTo alias a name of a field defined on a Javascript type to a PureScript function, use `foreign import member`. For example, to define a function `length` which accesses the `length` member of an array:\r\n\r\n```haskell\r\nforeign import member \"length\" length :: forall a. [a] -> Number\r\n```\r\n\r\n\r\n","google":"UA-33896432-1","note":"Don't delete this file! It's used internally to help with page regeneration."}